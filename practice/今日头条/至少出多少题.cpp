/*****************************************************************************************
头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队。
每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来。
在选题之前，我们对题目进行了盲审，并定出了每道题的难度系数。一场考试包含3道开放性题目，
假设他们的难度从小到大分别为a, b, c，我们希望这3道题能满足下列条件：
a＜= b＜= c
b - a＜= 10
c - b＜= 10
所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），
然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求。
然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？
*************************************************************************************************/
#include<iostream>  
#include<vector>  
#include<algorithm>  
using namespace std;
int main() {
	int n;  //n 表示题目数量  
	while (cin >> n) {
		vector<int> d;  //存储每道题目的难度  
		for (int i = 0; i<n; i++) {
			int tmp;
			cin >> tmp;
			d.push_back(tmp);
		} 
		sort(d.begin(), d.end());
		int cnt = 0;  //用来存储要加入的题目数量  
		int num = 0;  //存储当前连续的题目数量  
		int flag = -1;
		for (int k = 0; k<n; k++) {
			if (flag == -1) {  //说明是第一个数  
				num++;         //构成的第一个数
				flag = d[k];
			}
			else if ((d[k] - flag) <= 10) {  //说明这个数和前一个数满足条件   
				num++;
				if (num == 3) {//说明此时前面三个题目已经可以组成一场考试了   
					num = 0;    //重新赋值
					flag = -1;   
				}
				else 
					flag = d[k];  //此时为第二个数
			}
			else {  //说明和前一个数不满足相差小于等于10的情况   
				num++;
				cnt++;
				if (num == 3) {     //加一个数正好三个数，则一定可以组成考试
					num = 0;
					flag = -1;
				}
				else				//如果是两场，则第二场加到第一场+10
					flag += 10;
				k--;
			}
		}
		if (num != 0)             //num当前队列中的数字
			cnt += (3 - num);
		cout << cnt << endl;
	} 
	return 0;
}